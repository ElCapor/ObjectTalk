//	ObjectTalk Scripting Language
//	Copyright (c) 2020-2022 Johan A. Goossens. All rights reserved.
//
//	This work is licensed under the terms of the MIT license.
//	For a copy, see <https://opensource.org/licenses/MIT>.

var gui = import("gui");

//
//	This an abstract game class that implements state-transition logic
//	to simplify game development. The state of a game is stored in the "state"
//	property of an instance. Here is the life of a game within the arcade:
//
//	1.	Each game instance must have a "name" property and a "renderIcon" member
//		function. These are used by the arcade to display the initial menu.
//
//	2.	At the start, games are in the "setup" state. When entering this state,
//		this class creates a vector display for the game and stores a reference
//		in the "vd" property. This class adds the vector display to the app
//		and manages its visibility. At the same time, the game's "onSetup"
//		member function is called to allow the game to initialize. Once all
//		startup activities are done, the game enters the "idle" state.
//
//	3.	In the "idle" state, the game is dormant and the vector display is
//		disabled. The player is actually looking at the menu is this state so
//		all games are idling at this point.
//
//	4.	When a game is selected, it enters the "splash" state. When this happens,
//		the game's "onSelect" member function is called followed by a call to
//		"onShowSplash". When the player hits a button on the keyboard or the game
//		controller, an "onHideSplash" is sent and the game enters the "running"
//		state. The game now gets a "onStart" call.
//
//	5.	From now on, the game is in charge until the player aborts the game
//		using the escape key, hitting the X button on the controller or
//		when the game calls gameover.
//
//	6.	An optional "pause" state is available and the game can determine
//		when to do this. On entering this state, the "onPause" method is called.
//		After the player hits a button, the "onResume" method is called.
//
//	7.	When entering the "gameover" state, the game receive an "onStop" call
//		followed by an "onShowGameOver" call. Once the player hits a button,
//		"onHideGameOver" is called and the game returns to the idle state.
//		At this point the game is hidden and the menu is shown again.

class Game : Object {
	function setup(this, app) {
		// entering the startup state
		this.state = "setup";

		// create a vector display
		this.vd = gui.VectorDisplay(0, 0, 100, 100);
		this.vd.setBottomLeftOrigin();
		this.vd.setBrightness(1.1);
		this.vd.disable();
		app.add(this.vd);

		// let game initialize itself
		this.onSetup(app);

		// moving on to the "idle state"
		this.state = "idle";
	}

	function select(this) {
		// game has been selected from the menu, enter the "splash" state
		this.onSelect();
		this.state = "splash";
		this.onShowSplash();
		this.vd.enable();
	}

	function run(this) {
		// enter the running state
		this.onHideSplash();
		this.state = "running";
		this.onStart();
	}

	function pause(this) {
		// enter the pause state
		this.state = "pause";
		this.onPause();
	}

	function resume(this) {
		// re-enter the running state
		this.state = "running";
		this.onResume();
	}

	function abort(this) {
		// abort the current game and return to the menu
		if (this.state == "splash") {
			this.onHideSplash();

		} elif (this.state == "running") {
			this.onStop();

		} elif (this.state == "pause") {
			this.onResume();
			this.onStop();
		}

		this.vd.disable();
		this.state = "idle";
		this.OnEndCallback();
	}

	function gameover(this) {
		// enter the gameover state
		this.onStop();
		this.state = "gameover";
		this.onShowGameOver();
	}

	function end(this) {
		// re-enter the idle state
		this.onHideGameOver();
		this.state = "idle";
		this.vd.disable();
		this.OnEndCallback();
	}

	// keyboard and game controller callbacks
	// games must call these if they override them

	function handleButton(this, abort) {
		if (abort) {
			this.abort();

		} elif (this.state == "splash") {
			this.run();

		} elif (this.state == "pause") {
			this.resume();

		} elif (this.state == "gameover") {
			this.end();
		}
	}

	function onMouseButton(this, button, action, mods, x, y) {
		this.handleButton(false);
	}

	function onMouseMove(this, x, y) {
	}

	function onKey(this, key, mods) {
		this.handleButton(key == gui.keyEscape);
	}

	function onGamepadAxis(this, gamepad, axis, value) {
	}

	function onGamepadButton(this, gamepad, button, action) {
		this.handleButton(gamepad == 0 && button == 1);
	}

	// these member functions must be overridden by games
	function onSetup(this) {}
	function onSelect(this) {}
	function onShowSplash(this) {}
	function onHideSplash(this) {}
	function onStart(this) {}
	function update(this) {}
	function onPause(this) {}
	function onResume(this) {}
	function onStop(this) {}
	function onShowGameOver(this) {}
	function onHideGameOver(this) {}

	// callback for end of game
	function onEnd(this, callback) {
		this.OnEndCallback = callback;
	}

	// internal method to keep the scale right when screen is resized
	function scale(this, scale) {
		this.vd.setTransform(0, 0, scale);
		this.displayScale = scale;
	}
}

class SplashScreen : Object {
	function __init__(this, vd, y, text) {
		this.vd = vd;
		this.gfx = [];

		vd.pushStyle();
		vd.setCenteredText();
		vd.setColor("#47f");

		for line in text {
			this.gfx.append(vd.addText(8, y, 0.6, line));
			y -= 1;
		}

		vd.popStyle();
		this.hide();
	}

	function show(this) {
		for line in this.gfx {
			this.vd.enableShape(line);
		}
	}

	function hide(this) {
		for line in this.gfx {
			this.vd.disableShape(line);
		}
	}
}
