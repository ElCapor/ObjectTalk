//	ObjectTalk Scripting Language
//	Copyright (c) 2020-2023 Johan A. Goossens. All rights reserved.
//
//	This work is licensed under the terms of the MIT license.
//	For a copy, see <https://opensource.org/licenses/MIT>.

var gui = import("gui");

class ArcadeMenu : Object {
	function setup(this, app) {
		// create a vector display
		this.vd = gui.VectorDisplay(0, 0, 100, 100);
		this.vd.setTopLeftOrigin();
		this.vd.setBrightness(1.3);
		app.add(this.vd);
	}

	function buildMenu(this, items) {
		// create header
		this.vd.pushStyle();
		this.vd.setColor("#47f");
		this.vd.setWidth(2.0);
		this.vd.addText(3.9, 2.3, 1.0, "ObjectTalk Arcade");

		this.vd.setWidth(3.0);
		this.vd.addLine(3.9, 2.8, 12.8, 2.8);
		this.vd.popStyle();

		// calculate icon spacing
		var count = items.size();
		var gaps = 4 + count - 1;
		var gapSize = (16.0 - 3.2 * count) / gaps;
		var xOffset = gapSize * 2.0;
		var yOffset = 5.0;
		var selection = 0;

		// render all menu items
		for item in items {
			this.vd.pushStyle();
			this.vd.setColor("#99f");
			this.vd.setCenteredText();
			item.menu = this.vd.addRectangle(xOffset, yOffset, 3.2, 1.8);
			item.x0 = xOffset;
			item.x1 = xOffset + 3.2;
			item.y0 = yOffset;
			item.y1 = yOffset + 1.8;
			item.selection = selection++;

			this.vd.setColor("#274");
			var tw = this.vd.getTextWidth(item.name, 0.3);
			this.vd.addText(xOffset + 1.6, yOffset + 1.6, 0.3, item.name);
			this.vd.popStyle();

			item.renderIcon(this.vd, xOffset + 0.1, yOffset + 0.1, 3.0, 1.6);
			xOffset += 3.2 + gapSize;
		}

		// remember items
		this.items = items;
		this.updateSelection(0);
	}

	function onChoice(this, callback) {
		this.onChoiceCallback = callback;
	}

	function enable(this) {
		// enable our display
		this.vd.enable();
	}

	function disable(this) {
		// disable our display
		this.vd.disable();
	}

	function scale(this, scale) {
		// ensure display scaling is correct
		this.vd.setTransform(0, 0, scale);
		this.displayScale = scale;
	}

	function update(this) {
	}

	function updateSelection(this, item) {
		if (item < 0) {
			item = this.items.size() - 1;

		} elif (item == this.items.size()) {
			item = 0;
		}

		this.currentSelection = item;
		var index = 0;

		for item in this.items {
			if (this.currentSelection == index++) {
				this.vd.updateColor(item.menu, "#b33");
				this.vd.updateWidth(item.menu, 3.0);

			} else {
				this.vd.updateColor(item.menu, "#99f");
				this.vd.updateWidth(item.menu, 1.0);
			}
		}
	}

	function onMouseButton(this, button, action, mods, x, y) {
		x /= this.displayScale;
		y /= this.displayScale;

		for item in this.items {
			if (x >= item.x0 && x <= item.x1 && y >= item.y0 && y <= item.y1) {
				this.updateSelection(item.selection);
				this.onChoiceCallback(this.items[this.currentSelection]);
			}
		}
	}

	function onMouseMove(this, x, y) {
		x /= this.displayScale;
		y /= this.displayScale;

		for item in this.items {
			if (x >= item.x0 && x <= item.x1 && y >= item.y0 && y <= item.y1) {
				this.updateSelection(item.selection);
			}
		}
	}

	function onKey(this, key, mods) {
		if (key == gui.keyLeft) {
			this.updateSelection(this.currentSelection - 1);

		} elif (key == gui.keyRight) {
			this.updateSelection(this.currentSelection + 1);

		} elif (key == gui.keyEnter) {
			this.onChoiceCallback(this.items[this.currentSelection]);
		}
	}

	function onGamepadAxis(this, gamepad, axis, value) {
	}

	function onGamepadButton(this, gamepad, button, action) {
		if (gamepad == 0 && action) {
			if (button == 0) {
				this.updateSelection(this.currentSelection - 1);

			} elif (button == 2) {
				this.updateSelection(this.currentSelection + 1);

			} elif (button == 3) {
				this.onChoiceCallback(this.items[this.currentSelection]);
			}
		}
	}
}
